import { createClient } from '../client';
import type {
  Invoice,
  InvoiceInsert,
  InvoiceUpdate,
  InvoiceItem,
  InvoiceItemInsert,
} from '../types';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const supabase = createClient() as any;

// ============================================================================
// Invoices
// ============================================================================

export async function getInvoices(
  userId: string,
  options?: {
    status?: Invoice['status'] | Invoice['status'][];
    customerId?: string;
    startDate?: string;
    endDate?: string;
    limit?: number;
    overdue?: boolean;
  }
): Promise<Invoice[]> {
  let query = supabase
    .from('invoices')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: false });

  if (options?.status) {
    if (Array.isArray(options.status)) {
      query = query.in('status', options.status);
    } else {
      query = query.eq('status', options.status);
    }
  }

  if (options?.customerId) {
    query = query.eq('customer_id', options.customerId);
  }

  if (options?.startDate) {
    query = query.gte('issue_date', options.startDate);
  }

  if (options?.endDate) {
    query = query.lte('issue_date', options.endDate);
  }

  if (options?.overdue) {
    const today = new Date().toISOString().split('T')[0];
    query = query
      .lt('due_date', today)
      .not('status', 'eq', 'paid')
      .not('status', 'eq', 'cancelled');
  }

  if (options?.limit) {
    query = query.limit(options.limit);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data || [];
}

export async function getInvoiceById(id: string): Promise<Invoice | null> {
  const { data, error } = await supabase
    .from('invoices')
    .select('*')
    .eq('id', id)
    .single();

  if (error) {
    if (error.code === 'PGRST116') return null;
    throw error;
  }

  return data;
}

export async function getInvoiceByNumber(invoiceNumber: string): Promise<Invoice | null> {
  const { data, error } = await supabase
    .from('invoices')
    .select('*')
    .eq('invoice_number', invoiceNumber)
    .single();

  if (error) {
    if (error.code === 'PGRST116') return null;
    throw error;
  }

  return data;
}

export async function createInvoice(
  invoice: Omit<InvoiceInsert, 'invoice_number'>,
  items: Omit<InvoiceItemInsert, 'invoice_id'>[]
): Promise<Invoice> {
  // Calculate totals from items
  const subtotal = items.reduce((sum, item) => sum + item.total, 0);
  const taxRate = invoice.tax_rate ?? 0;
  const taxAmount = (subtotal * taxRate) / 100;
  const discountValue = invoice.discount ?? 0;
  const total = subtotal + taxAmount - discountValue;
  const balanceDue = total - (invoice.amount_paid ?? 0);

  // invoice_number is auto-generated by trigger
  const { data: invoiceData, error: invoiceError } = await supabase
    .from('invoices')
    .insert({
      ...invoice,
      subtotal,
      tax_amount: taxAmount,
      total,
      balance_due: balanceDue,
    })
    .select()
    .single();

  if (invoiceError) throw invoiceError;

  // Insert items
  if (items.length > 0) {
    const itemsWithInvoiceId = items.map((item) => ({
      ...item,
      invoice_id: invoiceData.id,
    }));

    const { error: itemsError } = await supabase
      .from('invoice_items')
      .insert(itemsWithInvoiceId);

    if (itemsError) throw itemsError;
  }

  return invoiceData;
}

export async function updateInvoice(id: string, updates: InvoiceUpdate): Promise<Invoice> {
  const { data, error } = await supabase
    .from('invoices')
    .update(updates)
    .eq('id', id)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function deleteInvoice(id: string): Promise<void> {
  // First delete all items
  const { error: itemsError } = await supabase
    .from('invoice_items')
    .delete()
    .eq('invoice_id', id);

  if (itemsError) throw itemsError;

  // Then delete the invoice
  const { error } = await supabase.from('invoices').delete().eq('id', id);

  if (error) throw error;
}

export async function markInvoiceAsPaid(
  id: string,
  paymentMethod?: string
): Promise<Invoice> {
  // First get current invoice to calculate balance
  const invoice = await getInvoiceById(id);
  if (!invoice) throw new Error('Invoice not found');

  return updateInvoice(id, {
    status: 'paid',
    paid_at: new Date().toISOString(),
    payment_method: paymentMethod,
    amount_paid: invoice.total,
    balance_due: 0,
  });
}

export async function markInvoiceAsSent(id: string): Promise<Invoice> {
  return updateInvoice(id, {
    status: 'sent',
    sent_at: new Date().toISOString(),
  });
}

export async function markInvoiceAsViewed(id: string): Promise<Invoice> {
  return updateInvoice(id, {
    status: 'viewed',
    viewed_at: new Date().toISOString(),
  });
}

export async function cancelInvoice(id: string): Promise<Invoice> {
  return updateInvoice(id, { status: 'cancelled' });
}

export async function recordPartialPayment(
  id: string,
  amountPaid: number,
  paymentMethod?: string
): Promise<Invoice> {
  const invoice = await getInvoiceById(id);
  if (!invoice) throw new Error('Invoice not found');

  const newAmountPaid = (invoice.amount_paid || 0) + amountPaid;
  const newBalanceDue = invoice.total - newAmountPaid;
  const newStatus = newBalanceDue <= 0 ? 'paid' : 'partial';

  return updateInvoice(id, {
    status: newStatus,
    amount_paid: newAmountPaid,
    balance_due: Math.max(0, newBalanceDue),
    payment_method: paymentMethod,
    ...(newStatus === 'paid' ? { paid_at: new Date().toISOString() } : {}),
  });
}

// ============================================================================
// Invoice Items
// ============================================================================

export async function getInvoiceItems(invoiceId: string): Promise<InvoiceItem[]> {
  const { data, error } = await supabase
    .from('invoice_items')
    .select('*')
    .eq('invoice_id', invoiceId)
    .order('created_at');

  if (error) throw error;
  return data || [];
}

export async function addInvoiceItem(item: InvoiceItemInsert): Promise<InvoiceItem> {
  const { data, error } = await supabase
    .from('invoice_items')
    .insert(item)
    .select()
    .single();

  if (error) throw error;

  // Recalculate invoice totals
  await recalculateInvoiceTotals(item.invoice_id);

  return data;
}

export async function updateInvoiceItem(
  id: string,
  updates: Partial<InvoiceItemInsert>
): Promise<InvoiceItem> {
  const { data, error } = await supabase
    .from('invoice_items')
    .update(updates)
    .eq('id', id)
    .select()
    .single();

  if (error) throw error;

  // Recalculate invoice totals
  await recalculateInvoiceTotals(data.invoice_id);

  return data;
}

export async function deleteInvoiceItem(id: string, invoiceId: string): Promise<void> {
  const { error } = await supabase.from('invoice_items').delete().eq('id', id);

  if (error) throw error;

  // Recalculate invoice totals
  await recalculateInvoiceTotals(invoiceId);
}

async function recalculateInvoiceTotals(invoiceId: string): Promise<void> {
  const items = await getInvoiceItems(invoiceId);
  const invoice = await getInvoiceById(invoiceId);
  if (!invoice) return;

  const subtotal = items.reduce((sum, item) => sum + item.total, 0);
  const taxAmount = (subtotal * (invoice.tax_rate || 0)) / 100;
  const total = subtotal + taxAmount - (invoice.discount || 0);
  const balanceDue = total - (invoice.amount_paid || 0);

  await updateInvoice(invoiceId, {
    subtotal,
    tax_amount: taxAmount,
    total,
    balance_due: balanceDue,
  });
}

// ============================================================================
// Stats
// ============================================================================

export async function getInvoiceStats(userId: string): Promise<{
  totalOutstanding: number;
  overdueCount: number;
  overdueAmount: number;
  paidThisMonth: number;
  totalInvoicesThisMonth: number;
}> {
  const today = new Date();
  const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1).toISOString();
  const todayStr = today.toISOString().split('T')[0];

  const { data, error } = await supabase
    .from('invoices')
    .select('status, total, due_date, paid_at')
    .eq('user_id', userId);

  if (error) throw error;

  type InvoiceSummary = { status: string; total?: number; due_date?: string | null; paid_at?: string | null };
  const invoices = (data || []) as InvoiceSummary[];

  // Outstanding (draft, sent, overdue, partial)
  const outstandingStatuses = ['draft', 'sent', 'overdue', 'partial'];
  const totalOutstanding = invoices
    .filter((inv) => outstandingStatuses.includes(inv.status))
    .reduce((sum: number, inv) => sum + (inv.total || 0), 0);

  // Overdue
  const overdueInvoices = invoices.filter(
    (inv) =>
      inv.due_date &&
      inv.due_date < todayStr &&
      !['paid', 'cancelled'].includes(inv.status)
  );
  const overdueCount = overdueInvoices.length;
  const overdueAmount = overdueInvoices.reduce((sum: number, inv) => sum + (inv.total || 0), 0);

  // Paid this month
  const paidThisMonth = invoices
    .filter((inv) => inv.status === 'paid' && inv.paid_at && inv.paid_at >= startOfMonth)
    .reduce((sum: number, inv) => sum + (inv.total || 0), 0);

  // Total invoices this month (created this month)
  const totalInvoicesThisMonth = invoices.filter(
    (inv) => inv.paid_at && inv.paid_at >= startOfMonth
  ).length;

  return {
    totalOutstanding,
    overdueCount,
    overdueAmount,
    paidThisMonth,
    totalInvoicesThisMonth,
  };
}

export async function getRecentInvoices(userId: string, limit = 10): Promise<Invoice[]> {
  return getInvoices(userId, { limit });
}

export async function getOverdueInvoices(userId: string): Promise<Invoice[]> {
  return getInvoices(userId, { overdue: true });
}
