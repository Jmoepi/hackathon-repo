import { createClient } from '../client';
import type {
  Order,
  OrderInsert,
  OrderUpdate,
  OrderItem,
  OrderItemInsert,
  MenuItem,
  MenuItemInsert,
  MenuItemUpdate,
} from '../types';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const supabase = createClient() as any;

// ============================================================================
// Menu Items
// ============================================================================

export async function getMenuItems(userId: string): Promise<MenuItem[]> {
  const { data, error } = await supabase
    .from('menu_items')
    .select('*')
    .eq('user_id', userId)
    .order('category')
    .order('name');

  if (error) throw error;
  return data || [];
}

export async function getAvailableMenuItems(userId: string): Promise<MenuItem[]> {
  const { data, error } = await supabase
    .from('menu_items')
    .select('*')
    .eq('user_id', userId)
    .eq('is_available', true)
    .order('category')
    .order('name');

  if (error) throw error;
  return data || [];
}

export async function createMenuItem(item: MenuItemInsert): Promise<MenuItem> {
  const { data, error } = await supabase
    .from('menu_items')
    .insert(item)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function updateMenuItem(id: string, updates: MenuItemUpdate): Promise<MenuItem> {
  const { data, error } = await supabase
    .from('menu_items')
    .update(updates)
    .eq('id', id)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function deleteMenuItem(id: string): Promise<void> {
  const { error } = await supabase.from('menu_items').delete().eq('id', id);
  if (error) throw error;
}

export async function toggleMenuItemAvailability(id: string, isAvailable: boolean): Promise<MenuItem> {
  return updateMenuItem(id, { is_available: isAvailable });
}

// ============================================================================
// Orders
// ============================================================================

export async function getOrders(
  userId: string,
  options?: {
    status?: Order['status'] | Order['status'][];
    orderType?: Order['order_type'];
    startDate?: string;
    endDate?: string;
    limit?: number;
  }
): Promise<Order[]> {
  let query = supabase
    .from('orders')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: false });

  if (options?.status) {
    if (Array.isArray(options.status)) {
      query = query.in('status', options.status);
    } else {
      query = query.eq('status', options.status);
    }
  }

  if (options?.orderType) {
    query = query.eq('order_type', options.orderType);
  }

  if (options?.startDate) {
    query = query.gte('created_at', options.startDate);
  }

  if (options?.endDate) {
    query = query.lte('created_at', options.endDate);
  }

  if (options?.limit) {
    query = query.limit(options.limit);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data || [];
}

export async function getOrderById(id: string): Promise<Order | null> {
  const { data, error } = await supabase
    .from('orders')
    .select('*')
    .eq('id', id)
    .single();

  if (error) {
    if (error.code === 'PGRST116') return null;
    throw error;
  }

  return data;
}

export async function getOrderWithItems(id: string): Promise<{ order: Order; items: OrderItem[] } | null> {
  const [orderResult, itemsResult] = await Promise.all([
    supabase.from('orders').select('*').eq('id', id).single(),
    supabase.from('order_items').select('*').eq('order_id', id),
  ]);

  if (orderResult.error) {
    if (orderResult.error.code === 'PGRST116') return null;
    throw orderResult.error;
  }

  if (itemsResult.error) throw itemsResult.error;

  return {
    order: orderResult.data,
    items: itemsResult.data || [],
  };
}

export async function createOrder(
  order: Omit<OrderInsert, 'order_number'>,
  items: Omit<OrderItemInsert, 'order_id'>[]
): Promise<{ order: Order; items: OrderItem[] }> {
  // Create order (order_number is auto-generated by trigger)
  const { data: newOrder, error: orderError } = await supabase
    .from('orders')
    .insert(order)
    .select()
    .single();

  if (orderError) throw orderError;

  // Create order items
  const orderItems: OrderItemInsert[] = items.map((item) => ({
    ...item,
    order_id: newOrder.id,
  }));

  const { data: newItems, error: itemsError } = await supabase
    .from('order_items')
    .insert(orderItems)
    .select();

  if (itemsError) throw itemsError;

  return {
    order: newOrder,
    items: newItems || [],
  };
}

export async function updateOrder(id: string, updates: OrderUpdate): Promise<Order> {
  const { data, error } = await supabase
    .from('orders')
    .update(updates)
    .eq('id', id)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function updateOrderStatus(id: string, status: Order['status']): Promise<Order> {
  const updates: OrderUpdate = { status };

  // Set timestamps based on status
  if (status === 'ready') {
    updates.ready_at = new Date().toISOString();
  } else if (status === 'completed') {
    updates.completed_at = new Date().toISOString();
  }

  return updateOrder(id, updates);
}

export async function cancelOrder(id: string): Promise<Order> {
  return updateOrderStatus(id, 'cancelled');
}

export async function markOrderAsPaid(id: string, paymentMethod: string): Promise<Order> {
  return updateOrder(id, {
    payment_status: 'paid',
    payment_method: paymentMethod,
  });
}

export async function getActiveOrders(userId: string): Promise<Order[]> {
  return getOrders(userId, {
    status: ['pending', 'confirmed', 'preparing', 'ready'],
  });
}

export async function getTodaysOrders(userId: string): Promise<Order[]> {
  const today = new Date();
  const startOfDay = new Date(today.setHours(0, 0, 0, 0)).toISOString();

  return getOrders(userId, {
    startDate: startOfDay,
  });
}

export async function getOrderStats(userId: string): Promise<{
  todayOrders: number;
  todayRevenue: number;
  pendingOrders: number;
  avgOrderValue: number;
}> {
  const today = new Date();
  const startOfDay = new Date(today.setHours(0, 0, 0, 0)).toISOString();

  const { data: todayOrders, error: todayError } = await supabase
    .from('orders')
    .select('total, status')
    .eq('user_id', userId)
    .gte('created_at', startOfDay);

  if (todayError) throw todayError;

  type OrderSummary = { total?: number; status?: string };
  const orders = (todayOrders || []) as OrderSummary[];
  const completedOrders = orders.filter((o) => o.status === 'completed');
  const pendingOrders = orders.filter((o) =>
    ['pending', 'confirmed', 'preparing', 'ready'].includes(o.status || '')
  );

  const todayRevenue = completedOrders.reduce((sum: number, o) => sum + (o.total || 0), 0);
  const avgOrderValue = completedOrders.length > 0 ? todayRevenue / completedOrders.length : 0;

  return {
    todayOrders: orders.length,
    todayRevenue,
    pendingOrders: pendingOrders.length,
    avgOrderValue: Math.round(avgOrderValue * 100) / 100,
  };
}
